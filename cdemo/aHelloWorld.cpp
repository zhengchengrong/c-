#include <vector>
#include <string>
#include <iostream> //这些iostream类可从文件和标准的输入输出设备（通常指控制台，但也可重定向到文件和设备）中读写数据。这个简单的程序将利用流对象在屏幕上显示消息。
#include <fstream>
#include <cstdlib> // c用来区分他是C的库，不加c，则表示是C++的库 
using namespace std; //标准的C++有预防这种冲突的机制：namespace关键字。库或程序中的每一个C++定义集被封装在一个名字空间中，如果其他的定义中有相同的名字，但它们在不同的名字空间，就不会产生冲突。
//可以用一个关键字来声明：“我要使用这个名字空间中的声明和（或）定义”。这个关键字是“using”。所有的标准C++库都封装在一个名字空间中，即“std”（代表“standard”）。由于本书常使用到这些标准的库文件，几乎在每个程序中都有如下的使用指令（using指令）：
//这意味着打开std名字空间，使它的所有名字都可用。有了这条语句，就不用担心特殊的库组件是在一个名字空间中，因为在使用using指令地方，它使名字空间在整个文件中都是可用的。

//名字空间和包含头文件的方法之间存在着相互关系。现代头文件的包含命令已标准化了（如＜iostream＞，不带扩展名“.h”），过去典型包含头文件的方式是带上“.h”，如＜iostream.h＞

// C/C++程序是变量、函数定义、函数调用的集合。程序开始运行时，它执行初始化代码并调用一个特殊的函数“main（）”。程序的主要代码放在这里。

// int main() {
	// hello world
/*	cout << "Hello World! I am" << 8 << " Today!" << endl;
	
*/
	// cin console input
	/*
	int number;
	cout << "Enter a decimal number:"; // 通过“＜＜”操作符把一系列的参数传递给cout对象,在控制台输出。 编译器为字符数组分配存储空间，把每个字符相应的ASCII码存放到这个空间中。编译器在字符数组后自动加上含“0”值的额外存储片，标志数组结束。
	cin >> number; // 接收控制台输入的内容  和cin一起使用的输入输出流操作符是“＞＞”。这个操作符接受与参数类型相同的输入
	cout << "value in octal = 0"
		<< oct << number << endl; //输入输出流函数endl表示一行结束并在行末加上一个换行符
	cout << "value in hex = 0x" 
		<< hex << number << endl; // hex 计算十六进制
	*/
	// 2.4.3 调用其他程序 典型的例子是在Unix shell脚本或DOS批处理文件中，使用从标准输入输出读写的程序。用标准的C语言system（）函数，C/C++程序可调用任何程序。system（）函数在头文件＜cstdlib＞中已声明
	//system("hello"); // 从这个程序可以看出，在C++中使用普通的C库函数是很容易的事，只要包含头文件和调用所需的库函数就行了。如果已经学过C语言，那么C与C++向上兼容的特性，会为学习C++带来很大的帮助。

	// 2.5 字符串 虽然字符数组很有用，但它有一定的限制。简单地说它就是存放在内存中的一组字符，如果要用它做什么事情，必须处理所有细节。例如，引号内字符数组的大小在编译时就确定了。如果想在这样的字符数组中添增字符，需要了解很多有关的知识（包括动态内存管理，字符数组的拷贝、连接等），才能完成添加任务。这正是我们所希望的有一种对象能替我们完成的事。
	// 标准的C++string类就是设计用来处理（并隐藏）对字符数组的低级操作，而这些操作早期是由C程序员来完成的。从有C语言以来这些操作就一直是一个编程费时、产生错误的原因。虽然本书第二卷中专门有一章介绍string类，但由于string能简化编程，对程序编写十分重要，所以，在此对它作一些介绍并加以使用。
	// 为使用string类，需要包含C++头文件＜string＞。string类在名字空间std中，因此要用using指令。由于操作符重载，string类的使用是很直观的：
	/*
	string s1, s2; // empty string 
	string s3 = "hello lwb ";
	string s4 = "are you ok";
	 s1 = s3 + s4;
	 s1 += " 8!";
	cout <<  s1 << endl; // 可以用“=”来给string对象赋值。“=”用其右边的内容代替string对象先前的内容。不必为先前的内容费心，它被自动处理。
	*/
	//连接string对象，只需用“+”操作符。“+”也可将string连接到字符数组中。如果想将string加到一个string或字符数组之后，可以用“+=”操作符完成这一操作。
	//最后说明一点，输入输出流知道如何来处理string，所以可直接向cout发送string（或能产生string的表达式，如上面的例子中的s1+s2+"！"）来打印它。

	// 2.6 文件的读写

	// 在C语言中，完成打开和处理文件这样复杂的操作，需要对C语言有较深的了解。然而C++语言的iostream库提供了一种简单的方法来处理文件，因此，介绍这个功能可以比在C语言中介绍这一功能更早。

	// 为了打开文件进行读写操作，必须包含＜fstream＞。虽然＜fstream＞会自动包含＜iostream＞，但如果打算使用cin, cout，最好还是显式地包含＜iostream＞

	// 为了读而打开文件，要创建一个ifstream对象，它的用法与cin相同，为了写而打开文件，要创建一个ofstream对象，用法与cout相同。一旦打开一个文件，就可以像处理其他iostream对象那样对它进行读写，非常简单。

	//在iostream库中，一个十分有用的函数是getline（），用它可以把一行读入到string对象中（以换行符结束）[1]。getline（）的第一个参数是ifstream对象，从中读取内容，第二个参数是stream对象。函数调用完成之后，string对象就装载了一行内容。


	//下面是一个简单的例子，将一个文件的内容拷贝到另一个文件：

	/*
	//https://www.cnblogs.com/batman425/p/3179520.html


	ifstream file1("f:\\1.txt"); // open for read
	ofstream file2("f:\\2.txt");  // open for writing 如果没有这个文件会自动创建
	string s;
	while (getline(file1,s)) // discards newline char getline（）的第一个参数是ifstream对象，从中读取内容，第二个参数是stream对象。函数调用完成之后，string对象就装载了一行内容。
	{
		file2 << s << "\n"; // ... must add it back
	}

	file1.close(); //用完要关闭资源
	file2.close();
	//getchar(); //不能在这里执行这个，不然文件写不进去。
	*/


	//另一个有趣味的例子是把整个文件拷贝成单独的一个string对象：
	/*
	ifstream file1("f:\\1.txt");
	string s, line;
	while (getline(file1,line))
	{
		s += line + "\n"; // string具有动态特性，不必担心string的内存分配；只管添加新内容进去就行了，string会自动扩展以保存新的输入。
		// 把整个文件都输入到一个字符串中，好处之一就是，string类有许多函数可用来对字符串进行查找和操作，使用它们可以把文件当成单个的字符串来处理。但
		// 也有一定的局限性。把一个文件作为许多行的集合而不是一大段文本来处理，通常是很方便的。例如，如果想对每一行都加上行号，把每行作为一个单独的string对象会非常容易。要完成这项工作，我们需用别的方
		// 扩展：这里可以参考java的字符串优化 https://www.cnblogs.com/dqqiu/p/5656444.html https://blog.csdn.net/weixin_36328444/article/details/79734967 https://www.cnblogs.com/justinli/p/4064128.html
	}
	cout << s;
	*/

	// 2.7 vector简介
	// 使用string，我们可以向string对象输入数据而不关心需要多少存储空间。但如果把每一行读入一个string对象，我们就不知道需要多少string―只有读完整个文件后才知道。为了解决这一问题，我们需要有某种能够自动扩展的存放设施，用以包含所需数量的string对象。
	// 实际上，为什么要限制我们自己只存放string对象呢？当编写程序时，很多情况下并不知道会用到多少什么东西。如果有某种“容器”对象，它能容纳所有的各种对象，这似乎更有用。幸运的是，标准C++库有一个现成的解决方法：标准容器（container）类。容器类是标准C++非常实用的强大工具之一。
	// 人们经常会把标准C++库的“容器”与“算法”和被称为STL的东西相混淆.最基本的标准容器―“vector”非常有用，在这里对它作一些介绍，以后会经常用到。我们会发现，使用vector后，可以进行大量的工作而不用关心底层的实现
	// vector类是一个模板（template），也就是说它可有效地用于不同的类型。就是说，我们可以创建Shape的vector、Cat的vector和String的vector等。用模板几乎可以创建“任何事物的类”。把类型名输入到尖括号内，让编译器知道vector所用的类（在这种情况下就是vector将要保存的类）。所以，string的vector表示为vector＜string＞。这样，就定制了只装string对象的vector。如果试图在这个vector中加入其他类型，编译器会给出错误提示信息。
	// 既然vector表达了“容器”的概念，就应该有一定的方法把东西放进容器中，并且能从容器里把东西取出来。为了在vector末尾后追加一个新元素，可以使用成员函数push_back（）
	// （注意，对于一个具体的对象要用“.”号来调用它的成员函数）。“push_back（）”这个名字看上去似乎有些冗长，不如“put”简单，这样命名是因为还有别的容器和成员函数也要向容器添加新元素。例如，insert（）成员函数，它是在容器中间加入新元素，vector支持这个函数，但它的用法更复杂，第2卷再解释它。还有push_front（）函数（不属于vector），它是把新元素加到vector的开头。在vector中，还有很多成员函数，在标准的C++类库中，还有很多容器，但是令人惊奇的是，仅仅知道一些简单的特征就能做许多事情了。
	// 可以用push_back（）向vector内添加新元素，但怎样从vector取回这些元素呢？解决的方法很巧妙―操作符重载，让vector像数组那样使用。几乎每一种编程语言都有数组这种数据类型（下一章将对它作更多的讨论）。数组是一个集合体，即它由许多元素构成。数组的一个显著特点是它所有的元素大小相同且逐个邻接。最重要的是元素可由“下标”（indexing）选定，这意味着，只要说“我要第n个元素”，就能找到这个元素，通常很快。除了某些特例，一般的编程语言下标都用方括号表示。比如，对于一个数组a，想提出第5个单元，就可以写成a[4]（注意下标总是从0开始）。

	// 正如“＜＜”和“＞＞”可用于iostreams类一样，通过操作符重载也可把简单有效的下标记号用于vector类中。不必知道重载是如何实现的―它留到下一章讨论―但是，如果知道为了使[]与vector一起操作而隐藏了的某些技巧，这对于加深理解是有帮助的。

	// 了解了上述内容，现在来看一个使用vector的程序。为使用vector，必须包含头文件＜vector＞：
	/*
	vector<string> v;
	ifstream inFile("f:\\1.txt");
	string line;
	while (getline(inFile,line)) {
		v.push_back(line); // 程序大部分与前一个程序相同，打开文件并每次将一行读进string对象。不同的是，这些string对象被压入vector v的尾部。while循环完成时，整个文件存在于v内，并驻留内存。
	}
	for (int i = 0; i < v.size(); i++) {
		cout << i << ": " << v[i] << endl;
	}
	inFile.close();
	*/

	// 为了进一步说明使用可带任何类型的vector是很容易的事，下面给出一个创建vector＜int＞的例子
	
	/*
	vector<int> v;
	for (int i = 0; i < 10; i++) {
		v.push_back(i);
	}

	for (int i = 0; i < v.size();i++) {
		cout << v[i] << ", ";
	}
	cout << endl;
	*/
	// 创建可以存放不同类型的vector，只需把类型当做模板参数（即在尖括号中的参数）输入即可。提供模板和设计完善的模板库正是为了使这种使用变得容易

	// 在这个例子中，我们还可以看到vector的另外一个重要特征。在表达式  v[i] = v[i] * 10;

	//中可以看到，vector不仅仅限于输入和取出，还可以通过使用方括号的下标操作符向vector的任何一个单元赋值（从而改变单元的值）。这说明vector是通用、灵活的“暂存器”，用来处理对象集。在后面几章我们将充分地利用它。	
	

	// 本章主要说明，如果有人已经定义了我们所需要的类，则面向对象编程是很容易的事。这时，只需简单的包含一个头文件，创建对象，并向对象发送消息。
	// 如果所用的类功能很强而且设计完善，那么我们不需费很多的力气就能编写出很好的程序。


	// 在显示使用库类使面向对象编程变得简单的过程中，本章也介绍了标准C++库中一些最基本的和十分有用的类型：一系列的输入输出流（特别是从文件和控制台进行读写的输入输出流）、string类和vector模板。可以看到使用这些库类是多么简单。现在可以想象用它们来编写程序完成许多工作，实际上，它们能做更多的事情[1]。虽然本书的前几章只用了这些工具很少的一部分功能，但对于用C这样的低级语言的编程方式已经是迈出了一大

	// 步。学习C语言的低层方面是为了教学目的，同时也很费时。如果用对象来管理低层的事务，最终会更有效。毕竟，面向对象编程就是要隐藏具体的细节，使我们着眼于程序设计更大的方面。

	// 尽管面向对象编程尽可能使编程工作在较高的层次上进行，但C语言的某些基本知识是不能不知道的，这些将在第3章中讨论


//	getchar();

// } // /:~

