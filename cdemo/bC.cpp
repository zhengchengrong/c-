// 因为C++是以C为基础的，所以要用C++编程就必须熟悉C的语法，就像要解决微积分问题必须要对代数十分了解一样

// 标准C和C++有一个特征叫做函数原型（function prototyping）。用函数原型，在声明和定义一个函数时，必须使用参数类型描述。这种描述就是“原型”。调用函数时，编译器使用原型确保正确传递参数并且正确地处理返回值。如果调用函数时程序员出错了，编译器就会捕获这个错误。

// 下面是一个声明函数原型的例子：int translate(float x,float y,float z);

// 在函数原型中声明变量时，不能使用和定义一般变量同样的形式。就是说不能用float x, y，z。必须指明每一个参数的类型。在函数声明中，下面的形式是可以接受的：

// int translate(float, float, float);

// 因为在调用函数时，编译器只是检查类型，所以使用标识符只是为了使别人阅读代码时更加清晰。

// 在函数定义中，因为参数是在函数内部引用的，所以需要命名.

/*
		int translate(float x,float y,float z){
			x = y = z;
			// ...
		}
*/

// 在不知道会有多少个参数或什么样类型的参数时，参数表的另一种选择是可变的参数列表。这个“不确定参数列表”用省略号（……）表示。定义一个带可变参数列表的函数比定义一个带固定参数列表的函数要复杂得多。如果（因为某种原因）不想使用函数原型的错误检查功能，可以对有固定参数表的函数使用可变参数列表。正因为如此，应该限制对C使用可变参数列表并且在C++中避免使用（正如我们将会看到的，在C++中有更好的选择）。在你的C指南的库部分对使用可变参数列表做了描述。

// 3.1.1 函数的返回值

/*

C++函数原型必须指明函数的返回值类型（在C中，如果省略返回值，表示默认为整型）。返回值的类型放在函数名的前面。为了表明没有返回值可以使用void关键字。如果这时试图从函数返回一个值会产生错误。下面有一些完整的函数原型：

要从一个函数返回值，我们必须使用return语句。return语句退出函数返回到函数调用后的那一点。如果return有参数，那个参数就是函数的返回值。如果函数规定返回一个特定类型的值，那么每一个return语句都必须返回这个类型。在一个函数定义中可以有多个return语句。



*/

#include <iostream>
using namespace std;

/*
char cfunc(int i) { //在函数cfunc（）中，第一个值为真的if语句，通过return语句退出函数。注意函数声明不是必须的，因为函数在main（）使用它之前定义，所以编译器从函数定义中知道它。
	if (i == 0)
		return 'a';
	if (i == 1) 
		return 'g';
	if (i == 5) 
		return 'z';
	return 'c';
}

int main() {
	cout << "type on integer:";
	int val;
	cin >> val;
	cout << cfunc(val) << endl;

	getchar();
	getchar();

}
*/
// 3.1.2 使用C的函数库

// 用C++编程时，当前C函数库中的所有函数都可以使用。在定义自己的函数之前，应该仔细地看一下函数库，可能有人已经解决了我们的问题，而且进行了更多的思考和调试。

// 注意，尽管很多编译器包含大量的额外函数可以使编程更加容易、吸引大家去使用，但是这并不是标准C库的一部分。如果我们肯定不想移植该应用程序到别的平台上（谁又能肯定呢？），那么就使用那些函数，让编程更加容易。如果希望该应用程序具有可移植性，就应该限制使用标准库函数。如果必须执行特定平台的活动，应当尽力把代码隔离在某一场所，以便移植到另一平台时容易进行修改。C++中，经常把特定平台的活动封装在一个类中，这是一个理想的解决办法。

// 使用库函数的方法如下：首先，在编程参考资料中查找函数（很多编程参考资料按字母顺序排序函数）。函数的描述应该包括说明代码语法的部分。这部分的头部通常至少有一#include行，表示包含函数原型的头文件。在程序文件中复制这个#include行，所以能正确声明函数。现在可以按照函数出现在语法部分的同样方式来调用它。如果出错了，编译器通过把函数调用和头文件中的函数原型相比较来报告错误。连接器通过默认路径查找标准库，所以在编程时需要做的就是包含这个头文件和调用这个函数。


// 3.1.3 通过库管理创建自己的库

/*
我们可以将自己的函数收集到一个库中。大多数编程包带有一个库管理器来管理对象模块组。每一个库管理器有它自己的命令，
但有这样一个共同的想法：如果想创建一个库，那么就建立一个头文件，它包含库中的所有函数原型。
把这个头文件放置在预处理器搜索路径中的某处，或者在当前目录中（以便能被#include“头文件”发现），或者在包含路径中（以便能被#include＜头文件＞发现）。
现在把所有的对象模块连同建成后的库名传递给库管理器（大多数库管理器要求有一个共同的扩展名，例如.lib或.a）。把建成的库和其他库放置在同一个位置以便连接器能发现它。
当使用自己的库时，必须向命令行添加一些东西，让连接器知道为你调用的函数查找库。
因为函数库随着系统而异，所以必须在你的系统手册中查找所有的细节。

*/

// 3.2 执行控制语句

/*
本节涵盖了C++中的执行控制语句。在读写C或C++代码之前，必须熟悉这些语句。

C++使用C的所有执行控制语句。这些语句包括if-else、while、do-while、for和switch选择语句。C++也允许使用声名狼藉的goto语句，在本书中会避免使用它。
*/

// 3.2.1　真和假
/*
所有的条件语句都使用条件表达式的真或假来判定执行路径。A==B是一个条件表达式的例子。这里使用条件运算符“==”确定变量A是否等于变量B。
表达式产生布尔值true（真）或false（假）（这只是C++中的关键字，在C中如果一个表达式等于非零值则为“真”）。其他的条件运算符有：＞、＜、＞=等。条件语句在本章的后面会有更详细的介绍
*/

// 3.2.2 if-else 语句

/*
if(表达式)
	语句
	或
if(表达式)
	语句
else
	语句
	“表达式”的值为真或假。“语句”是以一个分号结束的简单语句，或一组包含在大括号里的简单语句构成的一个复合语句。不管什么时候使用“语句”，都意味着是简单语句或复合语句。注意这个语句也可能是另一个if语句，所以它们可连成一串。
	缩进控制流语句体是一种习惯用法，以便读者可以很方便地知道它的起点和终点[1]。
*/

// 3.2.3 while语句

/*
while、do-while和for语句是循环控制语句。一个语句重复执行直到控制表达式的计值为假。while循环的形式是：

while(表达式)
	语句


循环一开始就对表达式进行计算。并在每次重复执行语句之前再次计算。下面的例子一直在while循环体内执行，直到输入密码或按control-C键。

while语句的条件表达式并不仅限于像上面的例子那样只进行一个简单的测试；
它也可以像我们希望的那样复杂，只要能产生一个真或假的结果。
我们甚至会看到没有循环体而只有一个分号代码：

while( Do a lot here);
在这样的情况下，程序员写的条件表达式既进行循环条件测试，又实现了具体任务。


*/

// 3.2.4 do-while语句
/*
 do-while 的形式是:
 do{
 语句
}while(表达式)
do-while语句与while语句的区别在于，即使表达式第一次计值就等于假，前面的语句也会至少执行一次。在一般的while语句中，如果条件第一次为假，语句一次也不会执行。

如果在程序Guess.cpp中使用do-while，变量guess不需要初始为0值，因为在它被检测之前就已被cin语句初始化了：

因为某种原因，大多数程序员更喜欢只使用while语句而避免使用do-while语句。
*/

// 3.2.5 for语句

/*
在第一次循环前，for循环执行初始化。然后它执行条件测试，并在每一次循环结束时执行某种形式的“步进”。for循环的形式是：

for(initialization;conditional;step)
	语句
表达式中的initialization、conditional或step都可能为空。一旦进入for循环，initialization代码就执行。在每一次循环之前，conditional被测试（如果它的计值一开始就为假，语句就不会执行）。每一次循环结束时，执行step。

for循环通常用于“计数”任务：
*/
/*
int main() {
	for (int i = 0; i < 128; i = i + 1)
		if (i != 26)
			cout << " value: " << i
			<< " character:"
			<< char(i) // Type conversion
			<< endl;
			
	getchar();
			return 0;
}
*/
// 3.2.6 关键字break和continue

/*
在任何一个while、do-while或for循环的结构体中，都能够使用break和continue控制循环的流程。break语句退出循环，不再执行循环中的剩余语句。continue语句停止执行当前的循环，返回到循环的起始处开始新的一轮循环。

作为break和continue语句的一个例子，下面程序是一个非常简单的菜单系统：


*/

// 3.2.7 switch语句

/*
switch语句根据一个整型表达式的值从几段代码中选择执行。它的形式是：

switch(selector){
case integral-value1 : statement;break;
case integral-value2 : statement;break;
case integral-value3 : statement;break;
case integral-value4 : statement;break;
case integral-value5 : statement;break;
(...)
default: statement;
}
选择器（selector）是一个产生整数值的表达式。switch语句把选择器（selector）的结果和每一个整数值（integral-value）比较。如果发现匹配，就执行对应的语句（简单语句或复合语句）。如果都不匹配，则执行default语句。

读者也许会注意到上面定义中的每一个case后面都以一个break语句作为结束，这个break语句使得执行跳转到switch语句体的结束处（完成switch的闭括号处）。这是建立switch语句的一种常用方式，但是break是可选的。如果省略它，case语句会顺序执行它后面的语句。也就是说，执行后面的各case语句代码，直到遇到一个break语句。尽管一般不需要这种举动，但是对于一个有经验的程序员来说这可能是有用的。

switch语句是一种清晰的实现多路选择的方式（即对不同的执行路径进行选择），但它需要一个能在编译时求得整数值的选择器。例如，如果想使用一个字符串类型的对象作为一个选择器，在switch语句中它是不能用的。对于字符串类型的选择器，必须使用一系列if语句并比较在条件中的字符串。



*/

// 3.2.9 递归

/*
递归是十分有趣的，有时也是非常有用的编程技巧，凭借递归我们可以在一个函数内部调用该函数。当然，如果这是所做的全部，那么会一直调用下去，直到内存用完，所以一定要有一种确定“达到底点”递归调用的方法。在下面的例子中，只要递归到cat的值超过‘Z’，递归就“达到底点”：[1]

在removeHat（）中，只要cat的值小于‘Z’，就会在removeHat（）中调用removeHat（），从而实现递归。每次调用removeHat（），它的参数比当前的cat值增加1，所以参数不断增加。
求解某些具有随意性的复杂问题经常使用递归，因为这时解的具体“大小”不受限制，函数可以一直递归调用，直到问题解决。


*/

// 3.3 运算符简介

/*
我们可以把运算符看做是一种特殊的函数（C++的运算符重载正是以这种方式对待运算符）。
一个运算符带一个或更多的参数并产生一个新值。
运算符参数和普通的函数调用参数相比在形式上不同，但是作用是一样的。
根据读者以前的编程经验，应该习惯于迄今使用的运算符。
任何一种编程语言的加（+）、减和单目减（-）、乘（*）、除（/）和赋值（=）的概念都有同样的意义。本章后面列举出全部运算符集

*/

// 3.3.1 优先级

/*
运算符优先级规定表达式中出现多个不同运算符时计值的运算顺序。C和C++中有具体的规则决定计值顺序。最容易记住的是先乘、除，后加、减。如果一个表达式的运算顺序对我们来说是不清晰的，那么对于任何一个读代码的人来说它都可能是不清晰的，所以应该使用括号使计值次序更加清晰。例如：
*/

// 3.3.2 自增和自减
/*
自减运算符是‘--’，意思是“减小一个单位”。自增运算符是‘++’，意思是“增加一个单位”。例如，如果A是一个整数，则++A等于（A=A+1）。自增和自减产生一个变量的值作为结果。
如果运算符在变量之前出现（即++A），则先执行运算，再产生结果值。
如果运算符在变量之后出现（即A++），则产生当前值，再执行运算。
如果我们曾经对“C++”这个名字感到奇怪，那么现在应该明白了。
C++隐含的意思就是“在C上更进一步”。
*/

// 3.4.1 基本内建类型
/*
标准C的内建类型（由C++继承）规范不说明每一个内建类型必须有多少位。规范只规定内建类型必须能存储的最大值和最小值。如果机器基于二进制，则最大值可以直接转换成容纳这个值所需的最少位数。然而，例如，如果一个机器使用二进制编码的十进制（BCD）来表示数字，在机器中容纳每一种数据类型的最大数值的空间是不同的。系统头文件limits.h和float.h中定义了不同的数据类型可能存储的最大值和最小值（在C++中，一般用#include＜climits＞和＜cfloat＞代替）

double类型存储浮点数，一般使用IEEE的浮点格式。float用于单精度浮点数，double用于双精度浮点数。

如前所述，我们可以在某一作用域的任何地方定义变量，可以同时定义和初始化它们。下面是怎样用这四种基本数据类型定义变量的例子：


*/
/*
int main() {

	char protein;
	int carbohydrates;
	float fiber;
	double fat;
	char pizza = 'A', pop = 'Z';
	int dongdings = 100, twinkles = 150,
		heehos = 200;
	float chocolate = 3.14159;
	double fudge_ripple = 6e-4;

}

//程序的第一部分定义了4种基本数据类型的变量，没有对变量初始化。
如果不初始化一个变量，标准会认为没有定义它的内容（通常，这意味着它们的内容是垃圾）。
程序的第二部分同时定义和初始化变量（如果可能，最好在定义时提供初始值）。
注意常量6e-4中指数符号的使用，意思是“6乘以10的负4次幂”。
*/

// 3.4.2 bool类型与true和false

/*
在bool类型成为标准C++的一部分之前，每个人都想使用不同的方法产生类似bool类型的行为。这产生了可移植性问题，可能会引入微妙的错误。

标准C++的bool类型有两种由内建的常量true（转换为整数1）和false（转换为整数0）表示的状态。这3个名字都是关键字。此外，一些语言元素也已经被采纳：

元素				布尔类型的用法
&& || !				带布尔参数并产生bool结果
<> <= >= == !=		产生bool结果
if,for,while,do		条件表达式转换为bool值
?:					第一个操作数转换为bool值

因为有很多现存的代码使用整型int表示一个标志，所以编译器隐式转换int为bool（非零值为true而零值为false）。理想的情况下，编译器会给我们一个警告，建议纠正这种情况。

用++把一个标志设置为真是一种“糟糕的编程风格”。这样做依然是允许的，但受到抵制，意味着在将来的某个时候它可能是不合法的。问题在于从bool到int做了隐式类型转换，增加了值（可能超过了0和1的正常布尔值的范围），然后再做相反的隐式转换。

指针（本章的后面将会引入）在必要的时候也自动转换成bool值。


*/

// 3.4.3 说明符

/*
说明符（specifier）用于改变基本内建类型的含义并把它们扩展成一个更大的集合。有4个说明符：long、short、signed和unsigned。

long和short修改数据类型具有的最大值和最小值。一般的int必须至少有short int型的大小。整数类型的大小等级是：short int、int、long int。只要满足最小/最大值的要求，所有的大小可以看成是一样的。例如，在64位字的机器上，所有的数据类型都可能是64位的。

浮点数的大小等级是：float、double和long double。“long float”是不合法的类型，也没有short浮点数。

signed和unsigned修饰符告诉编译器怎样使用整数类型和字符的符号位（浮点数总含有一个符号）。unsigned数不保存符号，因此有一个多余的位可用，所以它能存储比signed数大一倍的正数。signed是默认的，只有char才一定要使用


*/

// 3.4.4 指针简介

/*
不管什么时候运行一个程序，都是首先把它装入（一般从磁盘装入）计算机内存。因此，程序中的所有元素都驻留在内存的某处。
内存一般被布置成一系列连续的内存位置；
我们通常把这些位置看做是8位字节，但实际上每一个空间的大小取决于具体机器的结构，一般称为机器的字长（word size）。
每一个空间可按它的地址与其他空间区分。
为了便于讨论，我们认为所有机器都使用有连续地址的字节从零开始，一直到该计算机的内存的上限。
因为程序运行时驻留内存中，所以程序中的每一个元素都有地址。假设我们从一个简单的程序开始：

*/

/*
	int dog, cat, bird, fish; //在main外面定义的
	
	void f(int pet){
		cout << "pet id number:" << pet << endl;
	}

	int main() {
		int i, j, k;

		getchar();

	} // /:~
	*/
/*
程序运行的时候，程序中的每一个元素在内存中都占有一个位置。
甚至函数也占用内存。
我们将会看到，定义什么样的元素和定义元素的方式通常决定元素在内存中放置的地方。

C和C++中有一个运算符会告诉我们元素的地址。
这就是‘＆’运算符。只要在标识符前加上‘＆’，就会得出标识符的地址。
可以修改程序YourPets1.cpp，用以打印所有元素的地址。修改如下：



	int dog, cat, bird, fish; //在main外面定义的

	void f(int pet){
		cout << "pet id number:" << pet << endl;
	}

	int main() {
		int i, j, k;
		cout << "f():" << (long)&f << endl;
		cout << "dog:" << (long)&dog << endl;
		cout << "cat:" << (long)&cat << endl;
		cout << "bird:" << (long)&bird << endl;
		cout << "fish:" << (long)&fish << endl;
		cout << "i:" << (long)&i << endl;
		cout << "j:" << (long)&j << endl;
		cout << "k:" << (long)&k << endl;

		getchar();

	}


f():-1092021187

dog:-1091967232 相差 4个字节
cat:-1091967228 
bird:-1091967224
fish:-1091967220

i:-831522108 相差32位， 4 字节 x 8 位= 32
j:-831522076
k:-831522044

现在可以看到在函数main（）的内部和外部定义的变量存放在不同的区域；
当对语言有更多的了解时，就会明白为什么如此。
同样，f（）出现在它自己的区域，在内存中代码和数据一般是分开存放的。

另一个值得注意的有趣的事情是，相继定义的变量在内存中是连续存放的。

它们根据各自的数据类型所要求的字节数分隔开。
这个例子中只使用了整型数据类型，变量cat距离变量dog 4个字节，变量bird距离变量cat 4个字节，等等。
所以在这台机器上，一个int占4个字节。

这个有趣的实验显示了怎样分配内存，那么利用地址能干什么呢?能做的最重要的事就是，把地址存放在别的变量中以便以后使用。
C和C++有一个专门的存放地址的变量类型。这个变量叫做指针（pointer）。

定义指针的运算符和用于乘法的运算符‘*’是一样的。
正如我们将看到的那样，编译器会根据它所在的上下文知道它表示的不是乘法。


定义一个指针时，必须规定它指向的变量类型。可以先给出一个类型名，然后不是立即给出变量的标识符，而是在类型和标识符之间插入一个星号，这就是
说“等一等，它是一个指针”。一个指向int的指针如下所示：

int* ip; // ip points to an int variable

把‘*’和类型联系起来似乎是很明白且易读的，但是事实上可能容易产生错觉。
有人可能更倾向于说“整型指针”好像它是一个单独的类型。可是，对于int或其他的基本数据类型，可以写成

int a,b,c;
而对于指针，可能想写成
int* ipa,ipb,ipc;

C的语法（并由C++语法继承）不允许像这样合乎情理的表达。在上面的定义中，只有ipa是一个指针，而ipb和ipc是一般的int（可以认为“*和标识符结合得更紧密”）。因此，最好是每一行定义一个指针；这样就能得到一个清晰的语法而不会混淆：

int* ipa;
int* ipb;
int* ipc;

C++编程的一般原则是在定义时进行初始化，事实上这种形式工作得很好。例如，上面的变量并没有初始化为任何一个特定的值，它们所具有的是一些无意义的值。如果写成下面的形式会更好：

int a = 47;
int* ipa = &a;

现在已经初始化了a和ipa，ipa存放a的地址。

*/
// 3.4.6 C++引用简介

/*
在C和C++中指针的作用基本上是一样的，但是C++增加了另外一种给函数传递地址的途径。
这就是按引用传递（pass-by-reference），它也存在于一些其他的编程语言中，并不是C++的发明。
可能一开始我们会觉得没有必要使用引用，可以不用引用编写所有的程序。一般说来，除开在本书后面将要知道的一些重要地方，这是确实的。在后面我们将对引用有更多的了解，但是基本思想和前面所述的指针的使用是一样的：我们可以用引用传递参数地址。引用和指针的不同之处在于，带引用的函数调用比带指针的函数调用在语法构成上更清晰（在某种情况下，使用引用实质上的确只是语法构成上不同）。如果使用引用来修改程序PassAddress.cpp，我们能看到在main（）中函数调

*/

/*
void f(int& r) {
	cout << "r = " << r << endl;
	cout << "&r = " << &r << endl;
	r = 5;
	cout << "r = " << r << endl;
}

int main() {
	int x = 47;
	cout << "x = " << x << endl;
	cout << "&x = " << &x << endl;
	f(x);
	cout << "x = " << x << endl;
	getchar();

}
*/
/*
结果：
x = 47
&x = 000000C7594FFAE4
r = 47
&r = 000000C7594FFAE4
r = 5
x = 5

在函数f（）的参数列表中，不用int*来传递指针，而是用int＆来传递引用。在f（）中，如果仅仅写‘r’（如果r是一个指针，会产生一个地址值）会得到r引用的变量值。如果对r赋值，实际上是给r引用的变量赋值。事实上，得到r中存放的地址值的惟一方法是用‘＆’运算符。
在函数main（）中，我们能看到引用在调用函数f（）中的重要作用，其语法形式还是f（x）。尽管这看起来像是一般的按值传递，但是实际上引用的作用是传递地址，而不是值的一个拷贝。输出结果是：
所以我们可以看到，以引用传递允许一个函数去修改外部对象，就像传递一个指针所做的那样（读者可能也注意到引用使得地址传递这个事实不太明显，这在本书的后面会得到检验）。因此，通过这个简单的介绍，我们可以认为引用仅仅是语法上的一种不同方法（有时称为“语法糖”），它和指针完成同样的任务：允许函数去改变外部对象。



*/

// 3.4.7　用指针和引用作为修饰符

/*
迄今为止，我们已经看到了基本的数据类型char、int、float和double，看到了修饰符signed、unsigned、short和long，它们可以和基本的数据类型结合使用。现在我们增加了指针和引用（它们与基本数据类型和修饰符是独立的），所以可能产生三倍的结合：

*/
/*
void f1(char c, int i, float f, double d);
void f2(short int si, long int li, long double ld);
void f3(unsigned char uc, unsigned int ui,unsigned short int usi,unsigned long int uli);
void f4(char* cp, int* ip, float* fp, double* dp);
void f5(short int* sip, long int* lip, long double* ldp);
void f6(unsigned char* ucp, unsigned int* uip, unsigned short int* usip, unsigned long int* ulilp);
void f7(char& cr, int& ir, float& fr, double& dr);
void f8(short int& sir, long int& lir, long double& ldr);
void f9(unsigned char& ucr, unsigned int& uir, unsigned short int& usir, unsigned long int& ulir);
当传递对象进出函数时，指针和引用也能工作；我们将会在后面的一章了解到这些内容。
这里有和指针一起工作的另一种类型：void。如果声明指针是void*，它意味着任何类型的地址都可以间接引用那个指针（而如果声明int*，则只能对int型变量的地址间接引用那个指针）。例如：


*/
/*
int main() {
	void* vp;
	char c;
	int i;
	float f;
	double d;

	vp = &c;
	vp = &i;
	vp = &f;
	vp = &d;
	//一旦我们间接引用一个void*，就会丢失关于类型的信息。这意味着在使用前，必须转换为正确的类型：

	// 比如：
	int i = 99;
	void* vp = &i;
	*((int *)vp) = 3;

	// 转换（int*）vp告诉编译器把void*当做int*处理，因此可以成功地对它间接引用。读者可能注意到，这个语法很难看，的确如此，但是更糟的是，void*在语言类型系统中引入了一个漏洞。也就是说，它允许甚至是提倡把一种类型看做另一种类型。在上面的例子中，通过把vp转换为int*，把一个整型看做是一个整型，但是，并没有说不能把它转换为一个char*或double*，这将改变已经分配给int的存储空间的大小，可能会引起程序崩溃。一般来说，应当避免使用void指针，只有在一些少见的特殊情况下才用，到本书的后面才需要考虑这些。
}
*/

// 3.5 作用域

/*
作用域规则告诉我们一个变量的有效范围，它在哪里创建，在哪里销毁（也就是说，超出了作用域）。变量的有效作用域从它的定义点开始，到和定义变量之前最邻近的开括号配对的第一个闭括号。也就是说，作用域由变量所在的最近一对括号确定。说明如下
面的例子表明什么时候变量是可见的，什么时候变量是不可用的（即变量越出其作用域）。只有在变量的作用域内，才能使用它。作用域可以嵌套，即在一对大括号里面有其他的大括号对。嵌套意味着可以在我们所处的作用域内访问外层作用域的一个变量。上面的例子中，变量scp1在所有的作用域内都可用，而scp3只能在最里面的作用域内才可用。

*/

// 3.5.1 实时定义变量

/*
正如在本章前面提到的那样，定义变量时，C和C++有着显著的区别。
这两种语言都要求变量使用前必须定义，但是C（和很多其他的传统过程语言）强制在作用域的开始处就定义所有的变量，以便在编译器创建一个块时，能给所有这些变量分配空间
读C代码时，进入一个作用域，首先看到的是一个变量的定义块。在块的开始部分声明所有的变量，要求程序员以一种特定的方式写程序，因为语言的实现细节需要这样。大多数人在写代码之前并不知道他们将要使用的所有变量，所以他们必须不停地跳转回块的开头来插入新的变量，这是很不方便的，也会引起错误。这些变量定义对读者来说并没有很多含义，它们实际上只是容易引起混乱，因为它们出现的地方远离使用它们的上下文。

C++（不是C）允许在作用域内的任意地方定义变量，所以可以在正好使用它之前定义。此外，可以在定义变量时对它进行初始化以防止犯某种类型的错误。以这种方式定义变量使得编写代码更容易，减少了在一个作用域内不停地来回跳转造成的问题。因为可以在使用变量的上下文中看到所定义的变量，所以代码更容易理解。同时定义并初始化一个变量是非常重要的。通过使用变量的方式我们可以看到初始化一个变量值的意义。
我们还可以在for循环和while循环的控制表达式内定义变量，在if语句的条件表达式和switch的选择器语句内定义变量。下面是一个显示随时定义变量的例子：




int main() {
	int  q = 0;
	for (int i = 0; i < 100;i++) {
		q++;
		int p = 12;
	}
	cout << "Type characters:" << endl;
	while (char c =cin.get() != 'q') {
		if (char x = c == 'a' || c == 'b') {
			cout << "You typed a or b" << endl;
		}
		else {
			cout << "You typed" << x << endl;
		}
	}

	cout << "Type A,B, or C" << endl;
	switch (int i = cin.get())
	{
	case 'A': cout << "Snap" << endl; break;
	default:
		break;
	}
}
*/
/*
在最内层的作用域里，p是在作用域结束之前定义的，所以它只是一个毫无意义的表示（但它表明可以在任何地方定义一个变量）。在外层作用域中的p也是一样的情况。

在for循环的控制表达式中i的定义正是一个在需要的地方定义变量的例子（只能在C++中这样做）。i的作用域是for循环控制的表达式的作用域，所以可以轮到下一次for循环并重新使用i。这是在C++中一个非常方便和常
管例子表明在while语句、if语句和switch语句中也可以定义变量，但是可能因为语法受到许多限制，这种定义不如在for的表达式中常用。例如，我们不能有任何插入括号。也就是说，不可以写出：


附加的括号似乎是合理的，并且能做很有用的事，但因为无法使用它们，结果就不像所希望的那样。问题是因为‘！=’比‘=’的优先级高，所以char c最终含有的值是由bool转换为char的。当打印出来时，我们在很多终端上会看到一个笑脸字符。

通常，可以认为在while语句、if语句和switch语句中定义变量的能力是为了完备性，但是惟一使用这种变量定义的地方可能是在for循环中（在那里可能使用得十分频繁）。

*/
// 3.6 指定存储空间分配

/*
创建一个变量时，我们拥有指定变量生存期的很多选择，指定怎样给变量分配存储空间，以及指定编译器怎样处理这些变量。
*/

// 3.6.1 全局变量
/*
全局变量是在所有函数体的外部定义的，程序的所有部分（甚至其他文件中的代码）都可以使用。全局变量不受作用域的影响，总是可用的（也就是说，全局变量的生命期一直到程序的结束）。如果在一个文件中使用extern关键字来声明另一个文件中存在的全局变量，那么这个文件可以使用这个数据。例如：
*/
/*
int golbe;
void func();
int main() {
	golbe = 12;
}
*/
// 下面的程序把globe作为一个外部变量来访问：
/*
另一个文件中：
extern int globe;
void func() {
	globe = 47;
}

量globe的存储空间是由程序Global.cpp中的定义创建的，在Global2.cpp的代码中可以访问同一个变量。由于Global2.cpp和Global.cpp的代码是分段编译的，必须通过声明：

extern int globe;
告诉编译器变量存在哪里。
运行这个程序时，会看到函数func（）的调用的确影响globe的全局实例。

在Global.cpp中，可能看到下面这个特殊的注释标记（这是我自己的设计）：

// {L} Global2
这是说要创建最后的程序，带有Global2名字的目标文件必须被连接进来（这里没有扩展名是因为目标文件的扩展名在不同的系统中是不一样的）。在Global2.cpp中，第一行有另一个特殊的注释标记{O}，意思是“不要从这个文件生成可执行文件，编译它是为了把它连接进一些其他的可执行文件中。”本书第2卷中的ExtractCode.cpp程序（在www.BruceEckel.com上可以下载）阅读这些标记并生成适当的makefile使得每一个文件被正确地编译（在本章结束时将会了解makefile）。
*/

// 局部变量

/*
局部变量出现在一个作用域内，它们是局限于一个函数的。局部变量经常被称为自动变量（automatic variable），因为它们在进入作用域时自动生成，离开作用域时自动消失。关键字auto可以显式地说明这个问题，但是局部变量默认为auto，所以没有必要声明为auto。

// 3.6.2.1　寄存器变量
寄存器变量是一种局部变量。关键字register告诉编译器“尽可能快地访问这个变量”。加快访问速度取决于实现，但是，正如名字所暗示的那样，这经常是通过在寄存器中放置变量来做到的。这并不能保证将变量放置在寄存器中，甚至也不能保证提高访问速度。这只是对编译器的一个暗示。
使用register变量是有限制的。不可能得到或计算register变量的地址。register变量只能在一个块中声明（不可能有全局的或静态的register变量）。然而可以在一个函数中（即在参数表中）使用register变量作为一个形式参数。
一般地，不应当推测编译器的优化器，因为它可能比我们做得更好。因此，最好避免使用关键字register。
// 3.6.3　静态变量

关键字static有一些独特的意义。通常，函数中定义的局部变量在函数作用域结束时消失。当再次调用这个函数时，会重新创建该变量的存储空间，其值会被重新初始化。如果想使局部变量的值在程序的整个生命期里仍然存在，我们可以定义函数的局部变量为static（静态的），并给它一个初始值。初始化只在函数第一次调用时执行，函数调用之间变量的值保持不变。用这种方式，函数可以“记住”函数调用之间的一些信息片断。

// 3.6.4　外部变量
前面已经简要地描述和说明了extern关键字。它告诉编译器存在着一个变量和函数，即使编译器在当前编译的文件中没有看到它。这个变量或函数可能在另一个文件中或者在当前文件的后面定义。下面是一个例子：
当编译器遇到‘extern int i’时，它知道i肯定作为全局变量存在于某处。当编译器看到变量i的定义时，并没有看到别的声明，所以知道它在文件的前面已经找到了同样声明的i。如果已经把变量i定义为static，又要告诉编译器，i是全局定义的（通过extern），但是，它也有文件作用域（通过static），所以编译器会产生错误。

// 3.6.5　常量

在旧版本（标准前）的C中，如果想建立一个常量，必须使用预处理器：
*/
#define PI 3.14159
/*
无论在何地使用PI，都会被预处理器用值3.14159代替（在C和C++中都可以使用这个方法）。

当使用预处理器创建常量时，我们在编译器的范围之外能控制这些常量。对名字PI上不进行类型检查，也不能得到PI的地址（所以不能向PI传递一个指针和一个引用）。PI不能是用户定义的类型变量。PI的意义是从定义它的地方持续到文件结束的地方；预处理器并不识别作用域。

C++引入了命名常量的概念，命名常量就像变量一样，只是它的值不能改变。修饰符const告诉编译器这个名字表示常量。不管是内部的还是用户定义的数据类型都可以定义为const。如果定义了某对象为常量，然后试图修改它，编译器将会产生错误。

必须用下述方式说明一个常量类型：
const int x = 10;

在标准C和C++中，可以在参数列表中使用命名常量，即使列表中的参数是指针或引用（也就是说，可以获得const的地址）。const就像正常的变量一样有作用域，所以可以在函数中“隐藏”一个const，确保名字不会影响程序的其余部分。

const由C++采用，并加进标准C中，尽管它们很不一样。在C中，编译器对待const如同变量一样，只不过带有一个特殊的标记，意思是“不要改变我”。当在C中定义const时，编译器为它创建存储空间，所以如果在两个不同的文件中（或在头文件中）定义多个同名的const，连接器将生成发生冲突的错误消息。在C中使用const和在C++中使用const是完全不一样的（简而言之，在C++中使用得更好）。

合法的浮点常量值包括：1e4、1.0001、47.0、0.0和-1.159e-77。我们可以对数加后缀强加浮点数类型：f或F强加float型，L或l强加long double型，否则是double型。

// 3.6.6 volatile变量
限定词const告诉编译器“这是不会改变的”（这就允许编译器执行额外的优化）；而限定词volatile则告诉编译器“不知道何时会改变”，防止编译器依据变量的稳定性作任何优化。当读在代码控制之外的某个值时，例如读一块通信硬件中的寄存器，将使用这个关键字。无论何时需要volatile变量的值，都能读到，即使在该行之前刚刚读过。

（在java中用volatile，可以防止JVM底层进行优化而导致的多线程问题）
“在代码的控制之外”的某个存储空间的一个特殊例子是在多线程程序中。如果正在观察被另一个线程或进程修改的特殊标识符，这个标识符应该是volatile的，所以编译器不会认为它能够对标识符的多次读入进行优化。

注意当编译器不进行优化时，volatile可能不起作用，但是当开始优化代码时（当编译器开始寻找冗余的读入时），可以防止出现重大的错误。


3.7.2　数学运算符 + - * / 可以写成x+=4

3.7.3　关系运算符  < > == >= <=

3.7.4　逻辑运算符 逻辑运算符“与”（＆＆）和“或”（||）依据它们的参数的逻辑关系产生true或false。记住在C和C++中，如果语句是非零值则为true，如果是零则为false。如果打印一个bool值，一般会看到‘1’表示true、‘0’表示false。
在上面的程序中，我们可以用float或double代替int定义。但是，注意浮点数和零的比较是很严格的，一个数和另一个数即使只有最小小数位不同仍然是“不相等”。一个最小小数位大于0的浮点数仍为真。

3.7.5　位运算符 & 与 | 或  ^  非

& ：如果两个输入位都是1，则“与”运算符（＆）在结果位上产生1，否则为0

| : 如果两个输入位有一个是1，则“或”运算符（|）在结果位上产生1，只有当两个输入位都是0时，结果位才为0

^:如果两个输入位之一是1而不是同时为1，则位的异或运算符xor（^）的结果位为1。位的“非”运算符（～，也称为补运算符）是一个一元运算
符，它只带一个参数（其他的运算符都是二元运算符）。非运算符运算的结果和输入位相反，即输入位为0时结果位为1，输入位为1时结果位为0。

3.7.6　移位运算符
https://www.cnblogs.com/hongten/p/hongten_java_yiweiyunsuangfu.html
3.7.7　一元运算符
位的非运算不是惟一使用一个参数的运算符。和它一样，逻辑非（！）对一个true值得到一个false值。一元减（-）和一元加（+）是和二元减和二元加一样的运算符；根据表达式的书写方式，编译器能辨别属于哪一种用法。例如，语句
x = -a;

有明确的含义。

编译器可以理解
本章前面介绍了增量和减量运算符（++和--）。它们是涉及赋值的运算符中仅有的有副作用的运算符。这两个运算符使变量增加或减少一个单位，尽管对于不同的数据类型，“单位”可能有不同的含义―特别是对指针来说。

3.7.8　三元运算符
三元运算符if-else与众不同，因为它有三个操作数。这的确是一个运算符因为它产生一个值，而不是像一般的if-else语句那样。它由三个表达式组成：如果第一个表达式（后面跟有一个问号？）的计值为true，则对紧跟在问号后面的表达式求值，它的结果就是运算符的结果。如果第一个表达式为false，就执行第三个表达式（在冒号后面），它的结果就是运算符的结果。

可以使用if-else这个条件运算符的副作用或者它产生的值。下面的代码段说明了这两种情况：

a = --b ? b:(b -99);

这里，条件产生右值。如果b自减运算的结果非零，则把b的值赋给a。如果b变为零，a和b都被赋值为-99。b总是在递减，但是只有在b递减为0时，它才会被赋值为-99。可以使用如下不带“a=”的类似语句来利用它的副作用：


3.7.13　sizeof―独立运算符
sizeof单独作为一个运算符是因为它满足不同寻常的需要。sizeof给我们提供对有关数据项目所分配的内存大小。正如在本章前面叙述的那样，sizeof告诉我们任何变量使用的字节数。它也可以给出数据类型的大小（不用变量名）。

*/
/*
int main() {
	cout << "sizeof(double) = " << sizeof(double);
	cout << "sizeof(char) = " << sizeof(char);
}
*/
/*

按照定义，任何char（signed、unsigned或普通的）类型的sizeof都是1，不管char潜在的存储空间是否实际上是一个字节。对于所有别的类型，结果都是以字节表示的大小。

注意sizeof是一个运算符，不是函数。如果把它应用于一个类型，必须要像上面所示的那样使用括号，但是如果对一个变量使用它，可以不要括号。

3.7.14　asm关键字

这是一种转义（escape）机制，允许在C++程序中写汇编代码。在汇编程序代码中经常可以引用C++的变量，这意味着可以方便地和C++代码通信，且限定汇编代码只是用于必要的高效调整，或使用特殊的处理器指令。编写汇编语言时所必须使用的严格语法是依赖于编译器的，在编译器的文档中可以发现有关语法。

3.7.15　显式运算符
这是用于位运算符和逻辑运算符的关键字。没有＆、|、^这些键盘字符的非美国程序员被迫使用C的令人讨厌的三个图形字符（trigraph），这使得不但在输入字符的时候令人烦恼，而且在阅读时也含义模糊。在C++中用附加的关键字来修补这种情况。
如果读者的编译器遵从标准C++，它会支持这些关键字。


3.8　创建复合类型
基本的数据类型及其变体很重要，但也很简单。C和C++提供的工具允许把基本的数据类型组合成复杂的数据类型。正如我们将看到的那样，这些类型中最重要的是struct，在C++中这是类的基础。但是，创建比较复杂的类型的最简单的一种方式，只需要通过typedef来命名一个名字为另一个名字。
3.8.1　用typedef命名别名
这个关键字从字面上看的作用比它实际所起的作用更大：typedef表示“类型定义”，但用“别名”来描述可能更精确，因为这正是它真正的作用。它的语法是：


typedef原类型名别名
当数据类型稍微有点复杂时，人们经常使用typedef只是为了少敲几个键。下面是一种经常使用的typedef：

typedef unsigned long ulong;  ulong就代表编译器会认为他是 unsigned long

现在如果写ulong，则编译器知道意思是unsigned long。我们可能认为使用预处理程序置换就可以很容易实现，但是在一些重要的场合，编译器必须知道我们正在将名字当做类型处理，所以typedef起了关键作用。

typedef经常会派上用场的地方是指针类型。如前所述，如果写出


*/
/*
typedef int* IntPtr;
IntPtr x, y;
*/
/*
则x和y都是int*类型。

有人可能争辩说避免使用typedef定义基本类型会更清楚，因此更可读，而使用大量typedef时，程序的确很快变得难以阅读。
但是，在C中使用struct时，typedef是特别重要的。

3.8.2　用struct把变量结合在一起
struct（结构）是把一组变量组合成一个构造的一种方式。一旦创建了一个struct，就可以生成所建立的新类型变量的许多实例。例如：

*/
/*
struct Structurel
{
	char c;
	int i;
	float f;
	double d;
};

int main() {
	struct Structurel s1, s2; // 创建了两个Structure1的实例s1,s2
	s1.c = 'a';
	s1.i = 1;
	s1.f = 3.14;
	s1.d = 0.00093;
	s2.c = 'a';
	s2.i = 1;
	s2.f = 3.14;
}
*/
/*
typedef struct
{
	char c;
	int i;
	float f;
	double d;
} Structurel2;

int main() {
	Structurel2 s1, s2; // 创建了两个Structure1的实例s1,s2
	s1.c = 'a';
	s1.i = 1;
	s1.f = 3.14;
	s1.d = 0.00093;
	s2.c = 'a';
	s2.i = 1;
	s2.f = 3.14;
	s2.d = 0.00093;
}
*/
/*
注意这是使用Structure1的不便之处（正如所指出的那样，只是在C中需要，而不是C++）。
在C中，当定义变量时，不能只说Structure1，必须说struct Structure1。这就是在C中使用typedef特别方便的地方。

当定义s1和s2时（但是注意它只有数据和特征，并不包括行为，这就是在C++中得到的真正的对象），
通过这样使用typedef，可以假定Structure2是一个像int或float一样的内建类型（这是在C中；而在C++中，可以试图去掉typedef），
我们将会看到，struct标识符已经脱离了原来的目的，因为这里的目的是创造typedef。
当然，有时候可能需要早定义结构是使用struct。这时，可以重复struct的名字，就像struct名和typedef一样：

*/
/*
typedef struct SelfReferential {
	int i;
	SelfReferential* sr;
}SelfReferential;

int main() {
	SelfReferential sr1, sr2;
	sr1.sr = &sr2;
	sr1.sr = &sr1;
	sr1.i = 47;
	sr2.i = 1024;
}
*/
/*
如果看一下这个程序，会看到sr1和sr2互相指向且每个都拥有一块数据。

实际上，struct的名字不必和typedef的名字相同，但是，一般使用相同的名字，为了使得事物更加简单。

3.8.2.1　指针和struct

在上面的例子中，所有的struct都当做对象处理。但是，像任何一片存储空间一样，可以取得一个struct的地址（正如在上面的程序SelfReferential.cpp中看到的那样）。
如上所述，为了选择一个特定struct对象中的元素，应当使用‘.’。
但是，如果有一个指向struct对象的指针，可以使用一个不同的运算符‘-＞’来选择对象中的元素。下面是一个例子：

*/
typedef struct Structure3 {
	char c;
	int i;
	float f;
	double d;
} Structure3;

int main() {
	Structure3 s1, s2;
	Structure3* sp = &s1;
	sp->c = 'a';
	sp->i = 1;
	sp->f = 3.14;
	sp->d = 0.00093;
	sp = &s2;
	sp->c = 'a';
	sp->i = 1;
	sp->f = 3.14;
	sp->d = 0.00093;
} // /:~

/*
在main（）中，struct指针sp最初指向s1，用‘-＞’选择s1中的成员来初始化它们。
随后sp指向s2，以同样的方式初始化那些变量。
所以可以看到指针的另一个好处是可以动态地重定向它们，指向不同的对象，使编程更灵活。

到现在为止，这就是对struct需要了解的全部，但是随着本书的进展，我们会更自如地使用它们（特别是它们更有潜力的继任者―类）。

3.8.3　用enum提高程序清晰度

枚举数据类型是把名字和数字相联系的一种方式，从而对阅读代码的任何人给出更多的含义。
enum关键字（来自C）通过为所给出的任何标识符表赋值0、1、2等值来自动地列举出它们。
也可以声明enum变量（它们总是表示为整数值）。enum的声明和struct的声明很相似。
当想明了某种特征时，枚举数据类型是很有用的：

*/
/*
enum ShapeType {
	circle,
	square,
	rectangle
};

int main() {
	ShapeType shape = circle;
	switch (shape) {
	case circle:break;
	case square:break;
	}
}
*/
/*
shape是被列举的数据类型ShapeType的变量，可以把它的值和列举的值相比较。因为shape实际上只是int，所以它可以具有任何一个int拥有的值（包括负数）。也可以把int变量和枚举值比较。
读者可能意识到上面的类型转换例子对于程序有可能是一种值得怀疑的方式。C++对这类程序有一种更好的编码方式，对它的解释在本书的后面介绍。
*/
/*
3.8.4　用union节省内存
有时一个程序会使用同一个变量处理不同的数据类型。对于这种情况，有两种选择：可以创建一个struct，其中包含需要存储的所有可能的不同类型，或者可以使用union（联合）。union把所有的数据放进一个单独的空间内，它计算出放在union中的最大项所必需的空间数，并生成union的大小。使用union可以节省内存。

每当在union中放置一个值，这个值总是放在union开始的同一个地方，但是只使用必需的空间。因此，我们创建的是一个能容纳任何一个union变量的“超变量”。所有的union变量地址都是一样的（在类或struct中，地址是不同的）。

3.8.5　数组
数组是一种复合类型，因为它们允许在一个单一的标识符下把变量结合在一起，一个接着一个。如果写出
int a[10];

就为10个int变量创建了一个接一个的存储空间，但是每一个变量并没有单独的标识符。相反，它们都集结在名字a下。

要访问一个数组元素，可以使用定义数组时所使用的方括号语法：

a[5] = 47;

不过，必须记住，尽管a的大小是10，但是要从零开始选择数组元素（有时这被称为零指针），所以只可以选择数组元素0～9，如下所示：



*/

int main() {
	int a[10];
	for (int i = 0; i < 10; i++) {
		a[i] = i * 10;
		cout << "a[" << i << "] " << a[i] << endl;
	}
} ///:~

/*
访问数组是很快的。但是，如果下标超出数组的界限，这就不安全了，这可能会访问到别的变量。另一个缺陷是必须在编译期定义数组的大小；
如果想在运行期改变大小，则不能使用上面的语法（C有一种动态创建数组的方式，但是这会造成严重的混乱）。
在前面一章中介绍的C++向量提供了类似数组的对象，它能自动调整自身的大小，所以如果数组的大小在编译期不能确定的话，这是比较好的解决方法。

组的方式，但是这会造成严重的混乱）。在前面一章中介绍的C++向量提供了类似数组的对象，它能自动调整自身的大小，所以如果数组的大小在编译期不能确定的话，这是比较好的解决方法。

可以生成任何类型的数组，甚至是struct类型的：

*/

typedef struct {
	int i, j, k;
} ThreeDpoint;

int main() {
	ThreeDpoint p[10];
	for (int i = 0; i < 10; i++) {
		p[i].i = i + 1;
		p[i].j = i + 2;

	}
}
/*
注意：struct中的标识符i如何与for循环中的i无关。
为了知道数组中的相邻元素之间的距离，可以打印出地址如下：
当运行程序时，会看到每一个元素和前一个元素都是相距int大小的距离。也就是说，它们是一个接一个存放的。

3.8.5.1　指针和数组
*/
int main() {
	int a[10];
	cout << "a = " << a << endl;
	cout << "&a[0] =" << &a[0] << endl;
}
/*
数组的标识符不像一般变量的标识符。
一方面，数组标识符不是左值，不能给它赋值。
它只是一个进入方括号语法的手段，当给出数组名而没有方括号时，得到的就是数组的起始地址：
运行这个程序时，会看到这两个地址（因为没有转换为long，所以它以十六进制的形式打印出来）是一样的。
因此可以把数组标识符看做是数组起始处的只读指针。
尽管不能改变数组标识符指向，但是可以另创建指针，使它在数组中移动。事实上，方括号语法和指针一样工作：
*/
int main() {
	int a[10];
	int* ip = a;
	for (int i = 0; i < 10; i++)
		ip[i] = i * 10;

	*(ip + 1) = 10;
}

/*
当想给一个函数传递数组时，命名数组以产生它的起始地址的事实相当重要。如果声明一个数组为函数参数，实际上真正声明的是一个指针。所以在下面的例子中，func1（）和func2（）有一样的参数表：
*/

void func1(int a[],int size) {
	for (int i = 0; i < size; i++)
		a[i] = i * i - i;
}

void func2(int* a,int size) {
	for (int i = 0; i < size; i++) {
		a[i] = i * i + i;
	}
}

int main() {
	int a[5], b[5];
	func1(a, 5);
	func2(a, 5); // a 就是首地址 和 &a[0]等价
}