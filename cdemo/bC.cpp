// 因为C++是以C为基础的，所以要用C++编程就必须熟悉C的语法，就像要解决微积分问题必须要对代数十分了解一样

// 标准C和C++有一个特征叫做函数原型（function prototyping）。用函数原型，在声明和定义一个函数时，必须使用参数类型描述。这种描述就是“原型”。调用函数时，编译器使用原型确保正确传递参数并且正确地处理返回值。如果调用函数时程序员出错了，编译器就会捕获这个错误。

// 下面是一个声明函数原型的例子：int translate(float x,float y,float z);

// 在函数原型中声明变量时，不能使用和定义一般变量同样的形式。就是说不能用float x, y，z。必须指明每一个参数的类型。在函数声明中，下面的形式是可以接受的：

// int translate(float, float, float);

// 因为在调用函数时，编译器只是检查类型，所以使用标识符只是为了使别人阅读代码时更加清晰。

// 在函数定义中，因为参数是在函数内部引用的，所以需要命名.

/*
		int translate(float x,float y,float z){
			x = y = z;
			// ...
		}
*/

// 在不知道会有多少个参数或什么样类型的参数时，参数表的另一种选择是可变的参数列表。这个“不确定参数列表”用省略号（……）表示。定义一个带可变参数列表的函数比定义一个带固定参数列表的函数要复杂得多。如果（因为某种原因）不想使用函数原型的错误检查功能，可以对有固定参数表的函数使用可变参数列表。正因为如此，应该限制对C使用可变参数列表并且在C++中避免使用（正如我们将会看到的，在C++中有更好的选择）。在你的C指南的库部分对使用可变参数列表做了描述。

// 3.1.1 函数的返回值

/*

C++函数原型必须指明函数的返回值类型（在C中，如果省略返回值，表示默认为整型）。返回值的类型放在函数名的前面。为了表明没有返回值可以使用void关键字。如果这时试图从函数返回一个值会产生错误。下面有一些完整的函数原型：

要从一个函数返回值，我们必须使用return语句。return语句退出函数返回到函数调用后的那一点。如果return有参数，那个参数就是函数的返回值。如果函数规定返回一个特定类型的值，那么每一个return语句都必须返回这个类型。在一个函数定义中可以有多个return语句。



*/

#include <iostream>
using namespace std;

/*
char cfunc(int i) { //在函数cfunc（）中，第一个值为真的if语句，通过return语句退出函数。注意函数声明不是必须的，因为函数在main（）使用它之前定义，所以编译器从函数定义中知道它。
	if (i == 0)
		return 'a';
	if (i == 1) 
		return 'g';
	if (i == 5) 
		return 'z';
	return 'c';
}

int main() {
	cout << "type on integer:";
	int val;
	cin >> val;
	cout << cfunc(val) << endl;

	getchar();
	getchar();

}
*/
// 3.1.2 使用C的函数库

// 用C++编程时，当前C函数库中的所有函数都可以使用。在定义自己的函数之前，应该仔细地看一下函数库，可能有人已经解决了我们的问题，而且进行了更多的思考和调试。

// 注意，尽管很多编译器包含大量的额外函数可以使编程更加容易、吸引大家去使用，但是这并不是标准C库的一部分。如果我们肯定不想移植该应用程序到别的平台上（谁又能肯定呢？），那么就使用那些函数，让编程更加容易。如果希望该应用程序具有可移植性，就应该限制使用标准库函数。如果必须执行特定平台的活动，应当尽力把代码隔离在某一场所，以便移植到另一平台时容易进行修改。C++中，经常把特定平台的活动封装在一个类中，这是一个理想的解决办法。

// 使用库函数的方法如下：首先，在编程参考资料中查找函数（很多编程参考资料按字母顺序排序函数）。函数的描述应该包括说明代码语法的部分。这部分的头部通常至少有一#include行，表示包含函数原型的头文件。在程序文件中复制这个#include行，所以能正确声明函数。现在可以按照函数出现在语法部分的同样方式来调用它。如果出错了，编译器通过把函数调用和头文件中的函数原型相比较来报告错误。连接器通过默认路径查找标准库，所以在编程时需要做的就是包含这个头文件和调用这个函数。


// 3.1.3 通过库管理创建自己的库

/*
我们可以将自己的函数收集到一个库中。大多数编程包带有一个库管理器来管理对象模块组。每一个库管理器有它自己的命令，
但有这样一个共同的想法：如果想创建一个库，那么就建立一个头文件，它包含库中的所有函数原型。
把这个头文件放置在预处理器搜索路径中的某处，或者在当前目录中（以便能被#include“头文件”发现），或者在包含路径中（以便能被#include＜头文件＞发现）。
现在把所有的对象模块连同建成后的库名传递给库管理器（大多数库管理器要求有一个共同的扩展名，例如.lib或.a）。把建成的库和其他库放置在同一个位置以便连接器能发现它。
当使用自己的库时，必须向命令行添加一些东西，让连接器知道为你调用的函数查找库。
因为函数库随着系统而异，所以必须在你的系统手册中查找所有的细节。

*/

// 3.2 执行控制语句

/*
本节涵盖了C++中的执行控制语句。在读写C或C++代码之前，必须熟悉这些语句。

C++使用C的所有执行控制语句。这些语句包括if-else、while、do-while、for和switch选择语句。C++也允许使用声名狼藉的goto语句，在本书中会避免使用它。
*/

// 3.2.1　真和假
/*
所有的条件语句都使用条件表达式的真或假来判定执行路径。A==B是一个条件表达式的例子。这里使用条件运算符“==”确定变量A是否等于变量B。
表达式产生布尔值true（真）或false（假）（这只是C++中的关键字，在C中如果一个表达式等于非零值则为“真”）。其他的条件运算符有：＞、＜、＞=等。条件语句在本章的后面会有更详细的介绍
*/

// 3.2.2 if-else 语句

/*
if(表达式)
	语句
	或
if(表达式)
	语句
else
	语句
	“表达式”的值为真或假。“语句”是以一个分号结束的简单语句，或一组包含在大括号里的简单语句构成的一个复合语句。不管什么时候使用“语句”，都意味着是简单语句或复合语句。注意这个语句也可能是另一个if语句，所以它们可连成一串。
	缩进控制流语句体是一种习惯用法，以便读者可以很方便地知道它的起点和终点[1]。
*/

// 3.2.3 while语句

/*
while、do-while和for语句是循环控制语句。一个语句重复执行直到控制表达式的计值为假。while循环的形式是：

while(表达式)
	语句


循环一开始就对表达式进行计算。并在每次重复执行语句之前再次计算。下面的例子一直在while循环体内执行，直到输入密码或按control-C键。

while语句的条件表达式并不仅限于像上面的例子那样只进行一个简单的测试；
它也可以像我们希望的那样复杂，只要能产生一个真或假的结果。
我们甚至会看到没有循环体而只有一个分号代码：

while( Do a lot here);
在这样的情况下，程序员写的条件表达式既进行循环条件测试，又实现了具体任务。


*/

// 3.2.4 do-while语句
/*
 do-while 的形式是:
 do{
 语句
}while(表达式)
do-while语句与while语句的区别在于，即使表达式第一次计值就等于假，前面的语句也会至少执行一次。在一般的while语句中，如果条件第一次为假，语句一次也不会执行。

如果在程序Guess.cpp中使用do-while，变量guess不需要初始为0值，因为在它被检测之前就已被cin语句初始化了：

因为某种原因，大多数程序员更喜欢只使用while语句而避免使用do-while语句。
*/

// 3.2.5 for语句

/*
在第一次循环前，for循环执行初始化。然后它执行条件测试，并在每一次循环结束时执行某种形式的“步进”。for循环的形式是：

for(initialization;conditional;step)
	语句
表达式中的initialization、conditional或step都可能为空。一旦进入for循环，initialization代码就执行。在每一次循环之前，conditional被测试（如果它的计值一开始就为假，语句就不会执行）。每一次循环结束时，执行step。

for循环通常用于“计数”任务：
*/
/*
int main() {
	for (int i = 0; i < 128; i = i + 1)
		if (i != 26)
			cout << " value: " << i
			<< " character:"
			<< char(i) // Type conversion
			<< endl;
			
	getchar();
			return 0;
}
*/
// 3.2.6 关键字break和continue

/*
在任何一个while、do-while或for循环的结构体中，都能够使用break和continue控制循环的流程。break语句退出循环，不再执行循环中的剩余语句。continue语句停止执行当前的循环，返回到循环的起始处开始新的一轮循环。

作为break和continue语句的一个例子，下面程序是一个非常简单的菜单系统：


*/

// 3.2.7 switch语句

/*
switch语句根据一个整型表达式的值从几段代码中选择执行。它的形式是：

switch(selector){
case integral-value1 : statement;break;
case integral-value2 : statement;break;
case integral-value3 : statement;break;
case integral-value4 : statement;break;
case integral-value5 : statement;break;
(...)
default: statement;
}
选择器（selector）是一个产生整数值的表达式。switch语句把选择器（selector）的结果和每一个整数值（integral-value）比较。如果发现匹配，就执行对应的语句（简单语句或复合语句）。如果都不匹配，则执行default语句。

读者也许会注意到上面定义中的每一个case后面都以一个break语句作为结束，这个break语句使得执行跳转到switch语句体的结束处（完成switch的闭括号处）。这是建立switch语句的一种常用方式，但是break是可选的。如果省略它，case语句会顺序执行它后面的语句。也就是说，执行后面的各case语句代码，直到遇到一个break语句。尽管一般不需要这种举动，但是对于一个有经验的程序员来说这可能是有用的。

switch语句是一种清晰的实现多路选择的方式（即对不同的执行路径进行选择），但它需要一个能在编译时求得整数值的选择器。例如，如果想使用一个字符串类型的对象作为一个选择器，在switch语句中它是不能用的。对于字符串类型的选择器，必须使用一系列if语句并比较在条件中的字符串。



*/

// 3.2.9 递归

/*
递归是十分有趣的，有时也是非常有用的编程技巧，凭借递归我们可以在一个函数内部调用该函数。当然，如果这是所做的全部，那么会一直调用下去，直到内存用完，所以一定要有一种确定“达到底点”递归调用的方法。在下面的例子中，只要递归到cat的值超过‘Z’，递归就“达到底点”：[1]

在removeHat（）中，只要cat的值小于‘Z’，就会在removeHat（）中调用removeHat（），从而实现递归。每次调用removeHat（），它的参数比当前的cat值增加1，所以参数不断增加。
求解某些具有随意性的复杂问题经常使用递归，因为这时解的具体“大小”不受限制，函数可以一直递归调用，直到问题解决。


*/

// 3.3 运算符简介

/*
我们可以把运算符看做是一种特殊的函数（C++的运算符重载正是以这种方式对待运算符）。
一个运算符带一个或更多的参数并产生一个新值。
运算符参数和普通的函数调用参数相比在形式上不同，但是作用是一样的。
根据读者以前的编程经验，应该习惯于迄今使用的运算符。
任何一种编程语言的加（+）、减和单目减（-）、乘（*）、除（/）和赋值（=）的概念都有同样的意义。本章后面列举出全部运算符集

*/

// 3.3.1 优先级

/*
运算符优先级规定表达式中出现多个不同运算符时计值的运算顺序。C和C++中有具体的规则决定计值顺序。最容易记住的是先乘、除，后加、减。如果一个表达式的运算顺序对我们来说是不清晰的，那么对于任何一个读代码的人来说它都可能是不清晰的，所以应该使用括号使计值次序更加清晰。例如：
*/

// 3.3.2 自增和自减
/*
自减运算符是‘--’，意思是“减小一个单位”。自增运算符是‘++’，意思是“增加一个单位”。例如，如果A是一个整数，则++A等于（A=A+1）。自增和自减产生一个变量的值作为结果。
如果运算符在变量之前出现（即++A），则先执行运算，再产生结果值。
如果运算符在变量之后出现（即A++），则产生当前值，再执行运算。
如果我们曾经对“C++”这个名字感到奇怪，那么现在应该明白了。
C++隐含的意思就是“在C上更进一步”。
*/

// 3.4.1 基本内建类型
/*
标准C的内建类型（由C++继承）规范不说明每一个内建类型必须有多少位。规范只规定内建类型必须能存储的最大值和最小值。如果机器基于二进制，则最大值可以直接转换成容纳这个值所需的最少位数。然而，例如，如果一个机器使用二进制编码的十进制（BCD）来表示数字，在机器中容纳每一种数据类型的最大数值的空间是不同的。系统头文件limits.h和float.h中定义了不同的数据类型可能存储的最大值和最小值（在C++中，一般用#include＜climits＞和＜cfloat＞代替）

double类型存储浮点数，一般使用IEEE的浮点格式。float用于单精度浮点数，double用于双精度浮点数。

如前所述，我们可以在某一作用域的任何地方定义变量，可以同时定义和初始化它们。下面是怎样用这四种基本数据类型定义变量的例子：


*/
/*
int main() {

	char protein;
	int carbohydrates;
	float fiber;
	double fat;
	char pizza = 'A', pop = 'Z';
	int dongdings = 100, twinkles = 150,
		heehos = 200;
	float chocolate = 3.14159;
	double fudge_ripple = 6e-4;

}

//程序的第一部分定义了4种基本数据类型的变量，没有对变量初始化。
如果不初始化一个变量，标准会认为没有定义它的内容（通常，这意味着它们的内容是垃圾）。
程序的第二部分同时定义和初始化变量（如果可能，最好在定义时提供初始值）。
注意常量6e-4中指数符号的使用，意思是“6乘以10的负4次幂”。
*/

// 3.4.2 bool类型与true和false

/*
在bool类型成为标准C++的一部分之前，每个人都想使用不同的方法产生类似bool类型的行为。这产生了可移植性问题，可能会引入微妙的错误。

标准C++的bool类型有两种由内建的常量true（转换为整数1）和false（转换为整数0）表示的状态。这3个名字都是关键字。此外，一些语言元素也已经被采纳：

元素				布尔类型的用法
&& || !				带布尔参数并产生bool结果
<> <= >= == !=		产生bool结果
if,for,while,do		条件表达式转换为bool值
?:					第一个操作数转换为bool值

因为有很多现存的代码使用整型int表示一个标志，所以编译器隐式转换int为bool（非零值为true而零值为false）。理想的情况下，编译器会给我们一个警告，建议纠正这种情况。

用++把一个标志设置为真是一种“糟糕的编程风格”。这样做依然是允许的，但受到抵制，意味着在将来的某个时候它可能是不合法的。问题在于从bool到int做了隐式类型转换，增加了值（可能超过了0和1的正常布尔值的范围），然后再做相反的隐式转换。

指针（本章的后面将会引入）在必要的时候也自动转换成bool值。


*/

// 3.4.3 说明符

/*
说明符（specifier）用于改变基本内建类型的含义并把它们扩展成一个更大的集合。有4个说明符：long、short、signed和unsigned。

long和short修改数据类型具有的最大值和最小值。一般的int必须至少有short int型的大小。整数类型的大小等级是：short int、int、long int。只要满足最小/最大值的要求，所有的大小可以看成是一样的。例如，在64位字的机器上，所有的数据类型都可能是64位的。

浮点数的大小等级是：float、double和long double。“long float”是不合法的类型，也没有short浮点数。

signed和unsigned修饰符告诉编译器怎样使用整数类型和字符的符号位（浮点数总含有一个符号）。unsigned数不保存符号，因此有一个多余的位可用，所以它能存储比signed数大一倍的正数。signed是默认的，只有char才一定要使用


*/

// 3.4.4 指针简介

/*
不管什么时候运行一个程序，都是首先把它装入（一般从磁盘装入）计算机内存。因此，程序中的所有元素都驻留在内存的某处。
内存一般被布置成一系列连续的内存位置；
我们通常把这些位置看做是8位字节，但实际上每一个空间的大小取决于具体机器的结构，一般称为机器的字长（word size）。
每一个空间可按它的地址与其他空间区分。
为了便于讨论，我们认为所有机器都使用有连续地址的字节从零开始，一直到该计算机的内存的上限。
因为程序运行时驻留内存中，所以程序中的每一个元素都有地址。假设我们从一个简单的程序开始：

*/


	int dog, cat, bird, fish; //在main外面定义的
	
	void f(int pet){
		cout << "pet id number:" << pet << endl;
	}

	int main() {
		int i, j, k;

		getchar();

	} // /:~
/*
程序运行的时候，程序中的每一个元素在内存中都占有一个位置。
甚至函数也占用内存。
我们将会看到，定义什么样的元素和定义元素的方式通常决定元素在内存中放置的地方。

C和C++中有一个运算符会告诉我们元素的地址。
这就是‘＆’运算符。只要在标识符前加上‘＆’，就会得出标识符的地址。
可以修改程序YourPets1.cpp，用以打印所有元素的地址。修改如下：



	int dog, cat, bird, fish; //在main外面定义的

	void f(int pet){
		cout << "pet id number:" << pet << endl;
	}

	int main() {
		int i, j, k;
		cout << "f():" << (long)&f << endl;
		cout << "dog:" << (long)&dog << endl;
		cout << "cat:" << (long)&cat << endl;
		cout << "bird:" << (long)&bird << endl;
		cout << "fish:" << (long)&fish << endl;
		cout << "i:" << (long)&i << endl;
		cout << "j:" << (long)&j << endl;
		cout << "k:" << (long)&k << endl;

		getchar();

	}


f():-1092021187

dog:-1091967232 相差 4个字节
cat:-1091967228 
bird:-1091967224
fish:-1091967220

i:-831522108 相差32位， 4 字节 x 8 位= 32
j:-831522076
k:-831522044

现在可以看到在函数main（）的内部和外部定义的变量存放在不同的区域；
当对语言有更多的了解时，就会明白为什么如此。
同样，f（）出现在它自己的区域，在内存中代码和数据一般是分开存放的。

另一个值得注意的有趣的事情是，相继定义的变量在内存中是连续存放的。

它们根据各自的数据类型所要求的字节数分隔开。
这个例子中只使用了整型数据类型，变量cat距离变量dog 4个字节，变量bird距离变量cat 4个字节，等等。
所以在这台机器上，一个int占4个字节。

这个有趣的实验显示了怎样分配内存，那么利用地址能干什么呢?能做的最重要的事就是，把地址存放在别的变量中以便以后使用。
C和C++有一个专门的存放地址的变量类型。这个变量叫做指针（pointer）。

定义指针的运算符和用于乘法的运算符‘*’是一样的。
正如我们将看到的那样，编译器会根据它所在的上下文知道它表示的不是乘法。


定义一个指针时，必须规定它指向的变量类型。可以先给出一个类型名，然后不是立即给出变量的标识符，而是在类型和标识符之间插入一个星号，这就是
说“等一等，它是一个指针”。一个指向int的指针如下所示：

int* ip; // ip points to an int variable

把‘*’和类型联系起来似乎是很明白且易读的，但是事实上可能容易产生错觉。
有人可能更倾向于说“整型指针”好像它是一个单独的类型。可是，对于int或其他的基本数据类型，可以写成

int a,b,c;
而对于指针，可能想写成
int* ipa,ipb,ipc;

C的语法（并由C++语法继承）不允许像这样合乎情理的表达。在上面的定义中，只有ipa是一个指针，而ipb和ipc是一般的int（可以认为“*和标识符结合得更紧密”）。因此，最好是每一行定义一个指针；这样就能得到一个清晰的语法而不会混淆：

int* ipa;
int* ipb;
int* ipc;

C++编程的一般原则是在定义时进行初始化，事实上这种形式工作得很好。例如，上面的变量并没有初始化为任何一个特定的值，它们所具有的是一些无意义的值。如果写成下面的形式会更好：

int a = 47;
int* ipa = &a;

现在已经初始化了a和ipa，ipa存放a的地址。



*/